// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: api/proto/qemu.proto
// Protobuf C++ Version: 6.33.4

#ifndef api_2fproto_2fqemu_2eproto_2epb_2eh
#define api_2fproto_2fqemu_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fproto_2fqemu_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fproto_2fqemu_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_api_2fproto_2fqemu_2eproto;
}  // extern "C"
namespace elmos {
namespace v1 {
class ConsoleOutput;
struct ConsoleOutputDefaultTypeInternal;
extern ConsoleOutputDefaultTypeInternal _ConsoleOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConsoleOutput_class_data_;
class QEMUError;
struct QEMUErrorDefaultTypeInternal;
extern QEMUErrorDefaultTypeInternal _QEMUError_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUError_class_data_;
class QEMUInputRequest;
struct QEMUInputRequestDefaultTypeInternal;
extern QEMUInputRequestDefaultTypeInternal _QEMUInputRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUInputRequest_class_data_;
class QEMUInputResponse;
struct QEMUInputResponseDefaultTypeInternal;
extern QEMUInputResponseDefaultTypeInternal _QEMUInputResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUInputResponse_class_data_;
class QEMUOutput;
struct QEMUOutputDefaultTypeInternal;
extern QEMUOutputDefaultTypeInternal _QEMUOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUOutput_class_data_;
class QEMURunRequest;
struct QEMURunRequestDefaultTypeInternal;
extern QEMURunRequestDefaultTypeInternal _QEMURunRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMURunRequest_class_data_;
class QEMUStarted;
struct QEMUStartedDefaultTypeInternal;
extern QEMUStartedDefaultTypeInternal _QEMUStarted_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUStarted_class_data_;
class QEMUStatus;
struct QEMUStatusDefaultTypeInternal;
extern QEMUStatusDefaultTypeInternal _QEMUStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUStatus_class_data_;
class QEMUStatusRequest;
struct QEMUStatusRequestDefaultTypeInternal;
extern QEMUStatusRequestDefaultTypeInternal _QEMUStatusRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUStatusRequest_class_data_;
class QEMUStopRequest;
struct QEMUStopRequestDefaultTypeInternal;
extern QEMUStopRequestDefaultTypeInternal _QEMUStopRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUStopRequest_class_data_;
class QEMUStopResponse;
struct QEMUStopResponseDefaultTypeInternal;
extern QEMUStopResponseDefaultTypeInternal _QEMUStopResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUStopResponse_class_data_;
class QEMUStopped;
struct QEMUStoppedDefaultTypeInternal;
extern QEMUStoppedDefaultTypeInternal _QEMUStopped_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull QEMUStopped_class_data_;
}  // namespace v1
}  // namespace elmos
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace elmos {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class QEMUStopped final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUStopped) */ {
 public:
  inline QEMUStopped() : QEMUStopped(nullptr) {}
  ~QEMUStopped() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUStopped* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUStopped));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUStopped(::google::protobuf::internal::ConstantInitialized);

  inline QEMUStopped(const QEMUStopped& from) : QEMUStopped(nullptr, from) {}
  inline QEMUStopped(QEMUStopped&& from) noexcept
      : QEMUStopped(nullptr, ::std::move(from)) {}
  inline QEMUStopped& operator=(const QEMUStopped& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUStopped& operator=(QEMUStopped&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUStopped& default_instance() {
    return *reinterpret_cast<const QEMUStopped*>(
        &_QEMUStopped_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(QEMUStopped& a, QEMUStopped& b) { a.Swap(&b); }
  inline void Swap(QEMUStopped* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUStopped* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUStopped* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUStopped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUStopped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUStopped& from) { QEMUStopped::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUStopped* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUStopped"; }

  explicit QEMUStopped(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUStopped(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUStopped& from);
  QEMUStopped(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUStopped&& from) noexcept
      : QEMUStopped(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUptimeMsFieldNumber = 2,
    kExitCodeFieldNumber = 1,
  };
  // int64 uptime_ms = 2;
  void clear_uptime_ms() ;
  ::int64_t uptime_ms() const;
  void set_uptime_ms(::int64_t value);

  private:
  ::int64_t _internal_uptime_ms() const;
  void _internal_set_uptime_ms(::int64_t value);

  public:
  // int32 exit_code = 1;
  void clear_exit_code() ;
  ::int32_t exit_code() const;
  void set_exit_code(::int32_t value);

  private:
  ::int32_t _internal_exit_code() const;
  void _internal_set_exit_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUStopped)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUStopped& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t uptime_ms_;
    ::int32_t exit_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUStopped_class_data_;
// -------------------------------------------------------------------

class QEMUStopResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUStopResponse) */ {
 public:
  inline QEMUStopResponse() : QEMUStopResponse(nullptr) {}
  ~QEMUStopResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUStopResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUStopResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUStopResponse(::google::protobuf::internal::ConstantInitialized);

  inline QEMUStopResponse(const QEMUStopResponse& from) : QEMUStopResponse(nullptr, from) {}
  inline QEMUStopResponse(QEMUStopResponse&& from) noexcept
      : QEMUStopResponse(nullptr, ::std::move(from)) {}
  inline QEMUStopResponse& operator=(const QEMUStopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUStopResponse& operator=(QEMUStopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUStopResponse& default_instance() {
    return *reinterpret_cast<const QEMUStopResponse*>(
        &_QEMUStopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(QEMUStopResponse& a, QEMUStopResponse& b) { a.Swap(&b); }
  inline void Swap(QEMUStopResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUStopResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUStopResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUStopResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUStopResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUStopResponse& from) { QEMUStopResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUStopResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUStopResponse"; }

  explicit QEMUStopResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUStopResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUStopResponse& from);
  QEMUStopResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUStopResponse&& from) noexcept
      : QEMUStopResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUStopResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUStopResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUStopResponse_class_data_;
// -------------------------------------------------------------------

class QEMUStopRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUStopRequest) */ {
 public:
  inline QEMUStopRequest() : QEMUStopRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUStopRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUStopRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUStopRequest(::google::protobuf::internal::ConstantInitialized);

  inline QEMUStopRequest(const QEMUStopRequest& from) : QEMUStopRequest(nullptr, from) {}
  inline QEMUStopRequest(QEMUStopRequest&& from) noexcept
      : QEMUStopRequest(nullptr, ::std::move(from)) {}
  inline QEMUStopRequest& operator=(const QEMUStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUStopRequest& operator=(QEMUStopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUStopRequest& default_instance() {
    return *reinterpret_cast<const QEMUStopRequest*>(
        &_QEMUStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(QEMUStopRequest& a, QEMUStopRequest& b) { a.Swap(&b); }
  inline void Swap(QEMUStopRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUStopRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUStopRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<QEMUStopRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QEMUStopRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QEMUStopRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUStopRequest"; }

  explicit QEMUStopRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUStopRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUStopRequest& from);
  QEMUStopRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUStopRequest&& from) noexcept
      : QEMUStopRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUStopRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUStopRequest_class_data_;
// -------------------------------------------------------------------

class QEMUStatusRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUStatusRequest) */ {
 public:
  inline QEMUStatusRequest() : QEMUStatusRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUStatusRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUStatusRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUStatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline QEMUStatusRequest(const QEMUStatusRequest& from) : QEMUStatusRequest(nullptr, from) {}
  inline QEMUStatusRequest(QEMUStatusRequest&& from) noexcept
      : QEMUStatusRequest(nullptr, ::std::move(from)) {}
  inline QEMUStatusRequest& operator=(const QEMUStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUStatusRequest& operator=(QEMUStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUStatusRequest& default_instance() {
    return *reinterpret_cast<const QEMUStatusRequest*>(
        &_QEMUStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(QEMUStatusRequest& a, QEMUStatusRequest& b) { a.Swap(&b); }
  inline void Swap(QEMUStatusRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUStatusRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUStatusRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<QEMUStatusRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QEMUStatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QEMUStatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUStatusRequest"; }

  explicit QEMUStatusRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUStatusRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUStatusRequest& from);
  QEMUStatusRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUStatusRequest&& from) noexcept
      : QEMUStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUStatusRequest_class_data_;
// -------------------------------------------------------------------

class QEMUStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUStatus) */ {
 public:
  inline QEMUStatus() : QEMUStatus(nullptr) {}
  ~QEMUStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUStatus* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUStatus(::google::protobuf::internal::ConstantInitialized);

  inline QEMUStatus(const QEMUStatus& from) : QEMUStatus(nullptr, from) {}
  inline QEMUStatus(QEMUStatus&& from) noexcept
      : QEMUStatus(nullptr, ::std::move(from)) {}
  inline QEMUStatus& operator=(const QEMUStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUStatus& operator=(QEMUStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUStatus& default_instance() {
    return *reinterpret_cast<const QEMUStatus*>(
        &_QEMUStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(QEMUStatus& a, QEMUStatus& b) { a.Swap(&b); }
  inline void Swap(QEMUStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUStatus& from) { QEMUStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUStatus"; }

  explicit QEMUStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUStatus& from);
  QEMUStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUStatus&& from) noexcept
      : QEMUStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArchFieldNumber = 4,
    kRunningFieldNumber = 1,
    kPidFieldNumber = 2,
    kUptimeMsFieldNumber = 3,
    kMemoryMbFieldNumber = 5,
    kCpusFieldNumber = 6,
  };
  // string arch = 4;
  void clear_arch() ;
  const ::std::string& arch() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_arch(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_arch();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_arch();
  void set_allocated_arch(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_arch() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_arch(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_arch();

  public:
  // bool running = 1;
  void clear_running() ;
  bool running() const;
  void set_running(bool value);

  private:
  bool _internal_running() const;
  void _internal_set_running(bool value);

  public:
  // int32 pid = 2;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // int64 uptime_ms = 3;
  void clear_uptime_ms() ;
  ::int64_t uptime_ms() const;
  void set_uptime_ms(::int64_t value);

  private:
  ::int64_t _internal_uptime_ms() const;
  void _internal_set_uptime_ms(::int64_t value);

  public:
  // int32 memory_mb = 5;
  void clear_memory_mb() ;
  ::int32_t memory_mb() const;
  void set_memory_mb(::int32_t value);

  private:
  ::int32_t _internal_memory_mb() const;
  void _internal_set_memory_mb(::int32_t value);

  public:
  // int32 cpus = 6;
  void clear_cpus() ;
  ::int32_t cpus() const;
  void set_cpus(::int32_t value);

  private:
  ::int32_t _internal_cpus() const;
  void _internal_set_cpus(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 32,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr arch_;
    bool running_;
    ::int32_t pid_;
    ::int64_t uptime_ms_;
    ::int32_t memory_mb_;
    ::int32_t cpus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUStatus_class_data_;
// -------------------------------------------------------------------

class QEMUStarted final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUStarted) */ {
 public:
  inline QEMUStarted() : QEMUStarted(nullptr) {}
  ~QEMUStarted() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUStarted* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUStarted));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUStarted(::google::protobuf::internal::ConstantInitialized);

  inline QEMUStarted(const QEMUStarted& from) : QEMUStarted(nullptr, from) {}
  inline QEMUStarted(QEMUStarted&& from) noexcept
      : QEMUStarted(nullptr, ::std::move(from)) {}
  inline QEMUStarted& operator=(const QEMUStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUStarted& operator=(QEMUStarted&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUStarted& default_instance() {
    return *reinterpret_cast<const QEMUStarted*>(
        &_QEMUStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(QEMUStarted& a, QEMUStarted& b) { a.Swap(&b); }
  inline void Swap(QEMUStarted* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUStarted* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUStarted* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUStarted>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUStarted& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUStarted& from) { QEMUStarted::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUStarted* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUStarted"; }

  explicit QEMUStarted(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUStarted(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUStarted& from);
  QEMUStarted(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUStarted&& from) noexcept
      : QEMUStarted(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQemuVersionFieldNumber = 2,
    kCommandFieldNumber = 3,
    kPidFieldNumber = 1,
  };
  // string qemu_version = 2;
  void clear_qemu_version() ;
  const ::std::string& qemu_version() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_qemu_version(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_qemu_version();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_qemu_version();
  void set_allocated_qemu_version(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_qemu_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_qemu_version(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_qemu_version();

  public:
  // string command = 3;
  void clear_command() ;
  const ::std::string& command() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_command(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_command();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_command();
  void set_allocated_command(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_command() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_command(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_command();

  public:
  // int32 pid = 1;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUStarted)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUStarted& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr qemu_version_;
    ::google::protobuf::internal::ArenaStringPtr command_;
    ::int32_t pid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUStarted_class_data_;
// -------------------------------------------------------------------

class QEMURunRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMURunRequest) */ {
 public:
  inline QEMURunRequest() : QEMURunRequest(nullptr) {}
  ~QEMURunRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMURunRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMURunRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMURunRequest(::google::protobuf::internal::ConstantInitialized);

  inline QEMURunRequest(const QEMURunRequest& from) : QEMURunRequest(nullptr, from) {}
  inline QEMURunRequest(QEMURunRequest&& from) noexcept
      : QEMURunRequest(nullptr, ::std::move(from)) {}
  inline QEMURunRequest& operator=(const QEMURunRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMURunRequest& operator=(QEMURunRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMURunRequest& default_instance() {
    return *reinterpret_cast<const QEMURunRequest*>(
        &_QEMURunRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(QEMURunRequest& a, QEMURunRequest& b) { a.Swap(&b); }
  inline void Swap(QEMURunRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMURunRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMURunRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMURunRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMURunRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMURunRequest& from) { QEMURunRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMURunRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMURunRequest"; }

  explicit QEMURunRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMURunRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMURunRequest& from);
  QEMURunRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMURunRequest&& from) noexcept
      : QEMURunRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtraArgsFieldNumber = 5,
    kKernelCmdlineFieldNumber = 6,
    kGraphicalFieldNumber = 1,
    kDebugFieldNumber = 2,
    kMemoryMbFieldNumber = 3,
    kCpusFieldNumber = 4,
  };
  // repeated string extra_args = 5;
  int extra_args_size() const;
  private:
  int _internal_extra_args_size() const;

  public:
  void clear_extra_args() ;
  const ::std::string& extra_args(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_extra_args(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_extra_args(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_extra_args();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_extra_args(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& extra_args() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_extra_args();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_extra_args() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_extra_args();

  public:
  // string kernel_cmdline = 6;
  void clear_kernel_cmdline() ;
  const ::std::string& kernel_cmdline() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_kernel_cmdline(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_kernel_cmdline();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_kernel_cmdline();
  void set_allocated_kernel_cmdline(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_kernel_cmdline() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_kernel_cmdline(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_kernel_cmdline();

  public:
  // bool graphical = 1;
  void clear_graphical() ;
  bool graphical() const;
  void set_graphical(bool value);

  private:
  bool _internal_graphical() const;
  void _internal_set_graphical(bool value);

  public:
  // bool debug = 2;
  void clear_debug() ;
  bool debug() const;
  void set_debug(bool value);

  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);

  public:
  // int32 memory_mb = 3;
  void clear_memory_mb() ;
  ::int32_t memory_mb() const;
  void set_memory_mb(::int32_t value);

  private:
  ::int32_t _internal_memory_mb() const;
  void _internal_set_memory_mb(::int32_t value);

  public:
  // int32 cpus = 4;
  void clear_cpus() ;
  ::int32_t cpus() const;
  void set_cpus(::int32_t value);

  private:
  ::int32_t _internal_cpus() const;
  void _internal_set_cpus(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMURunRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMURunRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> extra_args_;
    ::google::protobuf::internal::ArenaStringPtr kernel_cmdline_;
    bool graphical_;
    bool debug_;
    ::int32_t memory_mb_;
    ::int32_t cpus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMURunRequest_class_data_;
// -------------------------------------------------------------------

class QEMUInputResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUInputResponse) */ {
 public:
  inline QEMUInputResponse() : QEMUInputResponse(nullptr) {}
  ~QEMUInputResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUInputResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUInputResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUInputResponse(::google::protobuf::internal::ConstantInitialized);

  inline QEMUInputResponse(const QEMUInputResponse& from) : QEMUInputResponse(nullptr, from) {}
  inline QEMUInputResponse(QEMUInputResponse&& from) noexcept
      : QEMUInputResponse(nullptr, ::std::move(from)) {}
  inline QEMUInputResponse& operator=(const QEMUInputResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUInputResponse& operator=(QEMUInputResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUInputResponse& default_instance() {
    return *reinterpret_cast<const QEMUInputResponse*>(
        &_QEMUInputResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(QEMUInputResponse& a, QEMUInputResponse& b) { a.Swap(&b); }
  inline void Swap(QEMUInputResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUInputResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUInputResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUInputResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUInputResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUInputResponse& from) { QEMUInputResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUInputResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUInputResponse"; }

  explicit QEMUInputResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUInputResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUInputResponse& from);
  QEMUInputResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUInputResponse&& from) noexcept
      : QEMUInputResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUInputResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUInputResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUInputResponse_class_data_;
// -------------------------------------------------------------------

class QEMUInputRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUInputRequest) */ {
 public:
  inline QEMUInputRequest() : QEMUInputRequest(nullptr) {}
  ~QEMUInputRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUInputRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUInputRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUInputRequest(::google::protobuf::internal::ConstantInitialized);

  inline QEMUInputRequest(const QEMUInputRequest& from) : QEMUInputRequest(nullptr, from) {}
  inline QEMUInputRequest(QEMUInputRequest&& from) noexcept
      : QEMUInputRequest(nullptr, ::std::move(from)) {}
  inline QEMUInputRequest& operator=(const QEMUInputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUInputRequest& operator=(QEMUInputRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUInputRequest& default_instance() {
    return *reinterpret_cast<const QEMUInputRequest*>(
        &_QEMUInputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(QEMUInputRequest& a, QEMUInputRequest& b) { a.Swap(&b); }
  inline void Swap(QEMUInputRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUInputRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUInputRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUInputRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUInputRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUInputRequest& from) { QEMUInputRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUInputRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUInputRequest"; }

  explicit QEMUInputRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUInputRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUInputRequest& from);
  QEMUInputRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUInputRequest&& from) noexcept
      : QEMUInputRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data() ;
  const ::std::string& data() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_data();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_data();
  void set_allocated_data(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_data() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUInputRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUInputRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUInputRequest_class_data_;
// -------------------------------------------------------------------

class QEMUError final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUError) */ {
 public:
  inline QEMUError() : QEMUError(nullptr) {}
  ~QEMUError() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUError* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUError));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUError(::google::protobuf::internal::ConstantInitialized);

  inline QEMUError(const QEMUError& from) : QEMUError(nullptr, from) {}
  inline QEMUError(QEMUError&& from) noexcept
      : QEMUError(nullptr, ::std::move(from)) {}
  inline QEMUError& operator=(const QEMUError& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUError& operator=(QEMUError&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUError& default_instance() {
    return *reinterpret_cast<const QEMUError*>(
        &_QEMUError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(QEMUError& a, QEMUError& b) { a.Swap(&b); }
  inline void Swap(QEMUError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUError* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUError& from) { QEMUError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUError* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUError"; }

  explicit QEMUError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUError& from);
  QEMUError(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUError&& from) noexcept
      : QEMUError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUError& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUError_class_data_;
// -------------------------------------------------------------------

class ConsoleOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.ConsoleOutput) */ {
 public:
  inline ConsoleOutput() : ConsoleOutput(nullptr) {}
  ~ConsoleOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConsoleOutput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConsoleOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConsoleOutput(::google::protobuf::internal::ConstantInitialized);

  inline ConsoleOutput(const ConsoleOutput& from) : ConsoleOutput(nullptr, from) {}
  inline ConsoleOutput(ConsoleOutput&& from) noexcept
      : ConsoleOutput(nullptr, ::std::move(from)) {}
  inline ConsoleOutput& operator=(const ConsoleOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsoleOutput& operator=(ConsoleOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsoleOutput& default_instance() {
    return *reinterpret_cast<const ConsoleOutput*>(
        &_ConsoleOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ConsoleOutput& a, ConsoleOutput& b) { a.Swap(&b); }
  inline void Swap(ConsoleOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsoleOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsoleOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConsoleOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConsoleOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConsoleOutput& from) { ConsoleOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConsoleOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.ConsoleOutput"; }

  explicit ConsoleOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConsoleOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConsoleOutput& from);
  ConsoleOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConsoleOutput&& from) noexcept
      : ConsoleOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
    kTimestampMsFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data() ;
  const ::std::string& data() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_data();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_data();
  void set_allocated_data(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_data() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // int64 timestamp_ms = 2;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:elmos.v1.ConsoleOutput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConsoleOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int64_t timestamp_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConsoleOutput_class_data_;
// -------------------------------------------------------------------

class QEMUOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:elmos.v1.QEMUOutput) */ {
 public:
  inline QEMUOutput() : QEMUOutput(nullptr) {}
  ~QEMUOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QEMUOutput* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QEMUOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QEMUOutput(::google::protobuf::internal::ConstantInitialized);

  inline QEMUOutput(const QEMUOutput& from) : QEMUOutput(nullptr, from) {}
  inline QEMUOutput(QEMUOutput&& from) noexcept
      : QEMUOutput(nullptr, ::std::move(from)) {}
  inline QEMUOutput& operator=(const QEMUOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline QEMUOutput& operator=(QEMUOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QEMUOutput& default_instance() {
    return *reinterpret_cast<const QEMUOutput*>(
        &_QEMUOutput_default_instance_);
  }
  enum EventCase {
    kStarted = 1,
    kConsole = 2,
    kStopped = 3,
    kError = 4,
    EVENT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(QEMUOutput& a, QEMUOutput& b) { a.Swap(&b); }
  inline void Swap(QEMUOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QEMUOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QEMUOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QEMUOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QEMUOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QEMUOutput& from) { QEMUOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QEMUOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "elmos.v1.QEMUOutput"; }

  explicit QEMUOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  QEMUOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QEMUOutput& from);
  QEMUOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, QEMUOutput&& from) noexcept
      : QEMUOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartedFieldNumber = 1,
    kConsoleFieldNumber = 2,
    kStoppedFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // .elmos.v1.QEMUStarted started = 1;
  bool has_started() const;
  private:
  bool _internal_has_started() const;

  public:
  void clear_started() ;
  const ::elmos::v1::QEMUStarted& started() const;
  [[nodiscard]] ::elmos::v1::QEMUStarted* PROTOBUF_NULLABLE release_started();
  ::elmos::v1::QEMUStarted* PROTOBUF_NONNULL mutable_started();
  void set_allocated_started(::elmos::v1::QEMUStarted* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_started(::elmos::v1::QEMUStarted* PROTOBUF_NULLABLE value);
  ::elmos::v1::QEMUStarted* PROTOBUF_NULLABLE unsafe_arena_release_started();

  private:
  const ::elmos::v1::QEMUStarted& _internal_started() const;
  ::elmos::v1::QEMUStarted* PROTOBUF_NONNULL _internal_mutable_started();

  public:
  // .elmos.v1.ConsoleOutput console = 2;
  bool has_console() const;
  private:
  bool _internal_has_console() const;

  public:
  void clear_console() ;
  const ::elmos::v1::ConsoleOutput& console() const;
  [[nodiscard]] ::elmos::v1::ConsoleOutput* PROTOBUF_NULLABLE release_console();
  ::elmos::v1::ConsoleOutput* PROTOBUF_NONNULL mutable_console();
  void set_allocated_console(::elmos::v1::ConsoleOutput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_console(::elmos::v1::ConsoleOutput* PROTOBUF_NULLABLE value);
  ::elmos::v1::ConsoleOutput* PROTOBUF_NULLABLE unsafe_arena_release_console();

  private:
  const ::elmos::v1::ConsoleOutput& _internal_console() const;
  ::elmos::v1::ConsoleOutput* PROTOBUF_NONNULL _internal_mutable_console();

  public:
  // .elmos.v1.QEMUStopped stopped = 3;
  bool has_stopped() const;
  private:
  bool _internal_has_stopped() const;

  public:
  void clear_stopped() ;
  const ::elmos::v1::QEMUStopped& stopped() const;
  [[nodiscard]] ::elmos::v1::QEMUStopped* PROTOBUF_NULLABLE release_stopped();
  ::elmos::v1::QEMUStopped* PROTOBUF_NONNULL mutable_stopped();
  void set_allocated_stopped(::elmos::v1::QEMUStopped* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_stopped(::elmos::v1::QEMUStopped* PROTOBUF_NULLABLE value);
  ::elmos::v1::QEMUStopped* PROTOBUF_NULLABLE unsafe_arena_release_stopped();

  private:
  const ::elmos::v1::QEMUStopped& _internal_stopped() const;
  ::elmos::v1::QEMUStopped* PROTOBUF_NONNULL _internal_mutable_stopped();

  public:
  // .elmos.v1.QEMUError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;

  public:
  void clear_error() ;
  const ::elmos::v1::QEMUError& error() const;
  [[nodiscard]] ::elmos::v1::QEMUError* PROTOBUF_NULLABLE release_error();
  ::elmos::v1::QEMUError* PROTOBUF_NONNULL mutable_error();
  void set_allocated_error(::elmos::v1::QEMUError* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_error(::elmos::v1::QEMUError* PROTOBUF_NULLABLE value);
  ::elmos::v1::QEMUError* PROTOBUF_NULLABLE unsafe_arena_release_error();

  private:
  const ::elmos::v1::QEMUError& _internal_error() const;
  ::elmos::v1::QEMUError* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:elmos.v1.QEMUOutput)
 private:
  class _Internal;
  void set_has_started();
  void set_has_console();
  void set_has_stopped();
  void set_has_error();
  inline bool has_event() const;
  inline void clear_has_event();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const QEMUOutput& from_msg);
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE started_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE console_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE stopped_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE error_;
    } event_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fproto_2fqemu_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull QEMUOutput_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// QEMURunRequest

// bool graphical = 1;
inline void QEMURunRequest::clear_graphical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graphical_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool QEMURunRequest::graphical() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMURunRequest.graphical)
  return _internal_graphical();
}
inline void QEMURunRequest::set_graphical(bool value) {
  _internal_set_graphical(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMURunRequest.graphical)
}
inline bool QEMURunRequest::_internal_graphical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.graphical_;
}
inline void QEMURunRequest::_internal_set_graphical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graphical_ = value;
}

// bool debug = 2;
inline void QEMURunRequest::clear_debug() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debug_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool QEMURunRequest::debug() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMURunRequest.debug)
  return _internal_debug();
}
inline void QEMURunRequest::set_debug(bool value) {
  _internal_set_debug(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMURunRequest.debug)
}
inline bool QEMURunRequest::_internal_debug() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debug_;
}
inline void QEMURunRequest::_internal_set_debug(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debug_ = value;
}

// int32 memory_mb = 3;
inline void QEMURunRequest::clear_memory_mb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_mb_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t QEMURunRequest::memory_mb() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMURunRequest.memory_mb)
  return _internal_memory_mb();
}
inline void QEMURunRequest::set_memory_mb(::int32_t value) {
  _internal_set_memory_mb(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMURunRequest.memory_mb)
}
inline ::int32_t QEMURunRequest::_internal_memory_mb() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memory_mb_;
}
inline void QEMURunRequest::_internal_set_memory_mb(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_mb_ = value;
}

// int32 cpus = 4;
inline void QEMURunRequest::clear_cpus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpus_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t QEMURunRequest::cpus() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMURunRequest.cpus)
  return _internal_cpus();
}
inline void QEMURunRequest::set_cpus(::int32_t value) {
  _internal_set_cpus(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMURunRequest.cpus)
}
inline ::int32_t QEMURunRequest::_internal_cpus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpus_;
}
inline void QEMURunRequest::_internal_set_cpus(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpus_ = value;
}

// repeated string extra_args = 5;
inline int QEMURunRequest::_internal_extra_args_size() const {
  return _internal_extra_args().size();
}
inline int QEMURunRequest::extra_args_size() const {
  return _internal_extra_args_size();
}
inline void QEMURunRequest::clear_extra_args() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_args_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL QEMURunRequest::add_extra_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_extra_args()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:elmos.v1.QEMURunRequest.extra_args)
  return _s;
}
inline const ::std::string& QEMURunRequest::extra_args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMURunRequest.extra_args)
  return _internal_extra_args().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL QEMURunRequest::mutable_extra_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMURunRequest.extra_args)
  return _internal_mutable_extra_args()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void QEMURunRequest::set_extra_args(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_extra_args()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:elmos.v1.QEMURunRequest.extra_args)
}
template <typename Arg_, typename... Args_>
inline void QEMURunRequest::add_extra_args(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_extra_args(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:elmos.v1.QEMURunRequest.extra_args)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& QEMURunRequest::extra_args()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:elmos.v1.QEMURunRequest.extra_args)
  return _internal_extra_args();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
QEMURunRequest::mutable_extra_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:elmos.v1.QEMURunRequest.extra_args)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extra_args();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
QEMURunRequest::_internal_extra_args() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extra_args_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
QEMURunRequest::_internal_mutable_extra_args() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extra_args_;
}

// string kernel_cmdline = 6;
inline void QEMURunRequest::clear_kernel_cmdline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kernel_cmdline_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& QEMURunRequest::kernel_cmdline() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMURunRequest.kernel_cmdline)
  return _internal_kernel_cmdline();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QEMURunRequest::set_kernel_cmdline(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.kernel_cmdline_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.QEMURunRequest.kernel_cmdline)
}
inline ::std::string* PROTOBUF_NONNULL QEMURunRequest::mutable_kernel_cmdline()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_kernel_cmdline();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMURunRequest.kernel_cmdline)
  return _s;
}
inline const ::std::string& QEMURunRequest::_internal_kernel_cmdline() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kernel_cmdline_.Get();
}
inline void QEMURunRequest::_internal_set_kernel_cmdline(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kernel_cmdline_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QEMURunRequest::_internal_mutable_kernel_cmdline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.kernel_cmdline_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QEMURunRequest::release_kernel_cmdline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.QEMURunRequest.kernel_cmdline)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.kernel_cmdline_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.kernel_cmdline_.Set("", GetArena());
  }
  return released;
}
inline void QEMURunRequest::set_allocated_kernel_cmdline(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.kernel_cmdline_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.kernel_cmdline_.IsDefault()) {
    _impl_.kernel_cmdline_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.QEMURunRequest.kernel_cmdline)
}

// -------------------------------------------------------------------

// QEMUOutput

// .elmos.v1.QEMUStarted started = 1;
inline bool QEMUOutput::has_started() const {
  return event_case() == kStarted;
}
inline bool QEMUOutput::_internal_has_started() const {
  return event_case() == kStarted;
}
inline void QEMUOutput::set_has_started() {
  _impl_._oneof_case_[0] = kStarted;
}
inline void QEMUOutput::clear_started() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kStarted) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.started_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.started_);
    }
    clear_has_event();
  }
}
inline ::elmos::v1::QEMUStarted* PROTOBUF_NULLABLE QEMUOutput::release_started() {
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUOutput.started)
  if (event_case() == kStarted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::QEMUStarted*>(_impl_.event_.started_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::elmos::v1::QEMUStarted& QEMUOutput::_internal_started() const {
  return event_case() == kStarted ? static_cast<const ::elmos::v1::QEMUStarted&>(*reinterpret_cast<::elmos::v1::QEMUStarted*>(_impl_.event_.started_))
                     : reinterpret_cast<const ::elmos::v1::QEMUStarted&>(::elmos::v1::_QEMUStarted_default_instance_);
}
inline const ::elmos::v1::QEMUStarted& QEMUOutput::started() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUOutput.started)
  return _internal_started();
}
inline ::elmos::v1::QEMUStarted* PROTOBUF_NULLABLE QEMUOutput::unsafe_arena_release_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:elmos.v1.QEMUOutput.started)
  if (event_case() == kStarted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::QEMUStarted*>(_impl_.event_.started_);
    _impl_.event_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QEMUOutput::unsafe_arena_set_allocated_started(
    ::elmos::v1::QEMUStarted* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_started();
    _impl_.event_.started_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:elmos.v1.QEMUOutput.started)
}
inline ::elmos::v1::QEMUStarted* PROTOBUF_NONNULL QEMUOutput::_internal_mutable_started() {
  if (event_case() != kStarted) {
    clear_event();
    set_has_started();
    _impl_.event_.started_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::elmos::v1::QEMUStarted>(GetArena()));
  }
  return reinterpret_cast<::elmos::v1::QEMUStarted*>(_impl_.event_.started_);
}
inline ::elmos::v1::QEMUStarted* PROTOBUF_NONNULL QEMUOutput::mutable_started()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::elmos::v1::QEMUStarted* _msg = _internal_mutable_started();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUOutput.started)
  return _msg;
}

// .elmos.v1.ConsoleOutput console = 2;
inline bool QEMUOutput::has_console() const {
  return event_case() == kConsole;
}
inline bool QEMUOutput::_internal_has_console() const {
  return event_case() == kConsole;
}
inline void QEMUOutput::set_has_console() {
  _impl_._oneof_case_[0] = kConsole;
}
inline void QEMUOutput::clear_console() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kConsole) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.console_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.console_);
    }
    clear_has_event();
  }
}
inline ::elmos::v1::ConsoleOutput* PROTOBUF_NULLABLE QEMUOutput::release_console() {
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUOutput.console)
  if (event_case() == kConsole) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::ConsoleOutput*>(_impl_.event_.console_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.console_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::elmos::v1::ConsoleOutput& QEMUOutput::_internal_console() const {
  return event_case() == kConsole ? static_cast<const ::elmos::v1::ConsoleOutput&>(*reinterpret_cast<::elmos::v1::ConsoleOutput*>(_impl_.event_.console_))
                     : reinterpret_cast<const ::elmos::v1::ConsoleOutput&>(::elmos::v1::_ConsoleOutput_default_instance_);
}
inline const ::elmos::v1::ConsoleOutput& QEMUOutput::console() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUOutput.console)
  return _internal_console();
}
inline ::elmos::v1::ConsoleOutput* PROTOBUF_NULLABLE QEMUOutput::unsafe_arena_release_console() {
  // @@protoc_insertion_point(field_unsafe_arena_release:elmos.v1.QEMUOutput.console)
  if (event_case() == kConsole) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::ConsoleOutput*>(_impl_.event_.console_);
    _impl_.event_.console_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QEMUOutput::unsafe_arena_set_allocated_console(
    ::elmos::v1::ConsoleOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_console();
    _impl_.event_.console_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:elmos.v1.QEMUOutput.console)
}
inline ::elmos::v1::ConsoleOutput* PROTOBUF_NONNULL QEMUOutput::_internal_mutable_console() {
  if (event_case() != kConsole) {
    clear_event();
    set_has_console();
    _impl_.event_.console_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::elmos::v1::ConsoleOutput>(GetArena()));
  }
  return reinterpret_cast<::elmos::v1::ConsoleOutput*>(_impl_.event_.console_);
}
inline ::elmos::v1::ConsoleOutput* PROTOBUF_NONNULL QEMUOutput::mutable_console()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::elmos::v1::ConsoleOutput* _msg = _internal_mutable_console();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUOutput.console)
  return _msg;
}

// .elmos.v1.QEMUStopped stopped = 3;
inline bool QEMUOutput::has_stopped() const {
  return event_case() == kStopped;
}
inline bool QEMUOutput::_internal_has_stopped() const {
  return event_case() == kStopped;
}
inline void QEMUOutput::set_has_stopped() {
  _impl_._oneof_case_[0] = kStopped;
}
inline void QEMUOutput::clear_stopped() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kStopped) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.stopped_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.stopped_);
    }
    clear_has_event();
  }
}
inline ::elmos::v1::QEMUStopped* PROTOBUF_NULLABLE QEMUOutput::release_stopped() {
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUOutput.stopped)
  if (event_case() == kStopped) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::QEMUStopped*>(_impl_.event_.stopped_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.stopped_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::elmos::v1::QEMUStopped& QEMUOutput::_internal_stopped() const {
  return event_case() == kStopped ? static_cast<const ::elmos::v1::QEMUStopped&>(*reinterpret_cast<::elmos::v1::QEMUStopped*>(_impl_.event_.stopped_))
                     : reinterpret_cast<const ::elmos::v1::QEMUStopped&>(::elmos::v1::_QEMUStopped_default_instance_);
}
inline const ::elmos::v1::QEMUStopped& QEMUOutput::stopped() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUOutput.stopped)
  return _internal_stopped();
}
inline ::elmos::v1::QEMUStopped* PROTOBUF_NULLABLE QEMUOutput::unsafe_arena_release_stopped() {
  // @@protoc_insertion_point(field_unsafe_arena_release:elmos.v1.QEMUOutput.stopped)
  if (event_case() == kStopped) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::QEMUStopped*>(_impl_.event_.stopped_);
    _impl_.event_.stopped_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QEMUOutput::unsafe_arena_set_allocated_stopped(
    ::elmos::v1::QEMUStopped* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_stopped();
    _impl_.event_.stopped_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:elmos.v1.QEMUOutput.stopped)
}
inline ::elmos::v1::QEMUStopped* PROTOBUF_NONNULL QEMUOutput::_internal_mutable_stopped() {
  if (event_case() != kStopped) {
    clear_event();
    set_has_stopped();
    _impl_.event_.stopped_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::elmos::v1::QEMUStopped>(GetArena()));
  }
  return reinterpret_cast<::elmos::v1::QEMUStopped*>(_impl_.event_.stopped_);
}
inline ::elmos::v1::QEMUStopped* PROTOBUF_NONNULL QEMUOutput::mutable_stopped()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::elmos::v1::QEMUStopped* _msg = _internal_mutable_stopped();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUOutput.stopped)
  return _msg;
}

// .elmos.v1.QEMUError error = 4;
inline bool QEMUOutput::has_error() const {
  return event_case() == kError;
}
inline bool QEMUOutput::_internal_has_error() const {
  return event_case() == kError;
}
inline void QEMUOutput::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void QEMUOutput::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kError) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.error_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.error_);
    }
    clear_has_event();
  }
}
inline ::elmos::v1::QEMUError* PROTOBUF_NULLABLE QEMUOutput::release_error() {
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUOutput.error)
  if (event_case() == kError) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::QEMUError*>(_impl_.event_.error_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::elmos::v1::QEMUError& QEMUOutput::_internal_error() const {
  return event_case() == kError ? static_cast<const ::elmos::v1::QEMUError&>(*reinterpret_cast<::elmos::v1::QEMUError*>(_impl_.event_.error_))
                     : reinterpret_cast<const ::elmos::v1::QEMUError&>(::elmos::v1::_QEMUError_default_instance_);
}
inline const ::elmos::v1::QEMUError& QEMUOutput::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUOutput.error)
  return _internal_error();
}
inline ::elmos::v1::QEMUError* PROTOBUF_NULLABLE QEMUOutput::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:elmos.v1.QEMUOutput.error)
  if (event_case() == kError) {
    clear_has_event();
    auto* temp = reinterpret_cast<::elmos::v1::QEMUError*>(_impl_.event_.error_);
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QEMUOutput::unsafe_arena_set_allocated_error(
    ::elmos::v1::QEMUError* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_error();
    _impl_.event_.error_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:elmos.v1.QEMUOutput.error)
}
inline ::elmos::v1::QEMUError* PROTOBUF_NONNULL QEMUOutput::_internal_mutable_error() {
  if (event_case() != kError) {
    clear_event();
    set_has_error();
    _impl_.event_.error_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::elmos::v1::QEMUError>(GetArena()));
  }
  return reinterpret_cast<::elmos::v1::QEMUError*>(_impl_.event_.error_);
}
inline ::elmos::v1::QEMUError* PROTOBUF_NONNULL QEMUOutput::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::elmos::v1::QEMUError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUOutput.error)
  return _msg;
}

inline bool QEMUOutput::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void QEMUOutput::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline QEMUOutput::EventCase QEMUOutput::event_case() const {
  return QEMUOutput::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// QEMUStarted

// int32 pid = 1;
inline void QEMUStarted::clear_pid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t QEMUStarted::pid() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStarted.pid)
  return _internal_pid();
}
inline void QEMUStarted::set_pid(::int32_t value) {
  _internal_set_pid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStarted.pid)
}
inline ::int32_t QEMUStarted::_internal_pid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pid_;
}
inline void QEMUStarted::_internal_set_pid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_ = value;
}

// string qemu_version = 2;
inline void QEMUStarted::clear_qemu_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qemu_version_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& QEMUStarted::qemu_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStarted.qemu_version)
  return _internal_qemu_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QEMUStarted::set_qemu_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.qemu_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStarted.qemu_version)
}
inline ::std::string* PROTOBUF_NONNULL QEMUStarted::mutable_qemu_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_qemu_version();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUStarted.qemu_version)
  return _s;
}
inline const ::std::string& QEMUStarted::_internal_qemu_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.qemu_version_.Get();
}
inline void QEMUStarted::_internal_set_qemu_version(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qemu_version_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QEMUStarted::_internal_mutable_qemu_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.qemu_version_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QEMUStarted::release_qemu_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUStarted.qemu_version)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.qemu_version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.qemu_version_.Set("", GetArena());
  }
  return released;
}
inline void QEMUStarted::set_allocated_qemu_version(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.qemu_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.qemu_version_.IsDefault()) {
    _impl_.qemu_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.QEMUStarted.qemu_version)
}

// string command = 3;
inline void QEMUStarted::clear_command() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.command_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& QEMUStarted::command() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStarted.command)
  return _internal_command();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QEMUStarted::set_command(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.command_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStarted.command)
}
inline ::std::string* PROTOBUF_NONNULL QEMUStarted::mutable_command()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUStarted.command)
  return _s;
}
inline const ::std::string& QEMUStarted::_internal_command() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.command_.Get();
}
inline void QEMUStarted::_internal_set_command(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.command_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QEMUStarted::_internal_mutable_command() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.command_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QEMUStarted::release_command() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUStarted.command)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.command_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.command_.Set("", GetArena());
  }
  return released;
}
inline void QEMUStarted::set_allocated_command(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.command_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.command_.IsDefault()) {
    _impl_.command_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.QEMUStarted.command)
}

// -------------------------------------------------------------------

// ConsoleOutput

// bytes data = 1;
inline void ConsoleOutput::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ConsoleOutput::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.ConsoleOutput.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ConsoleOutput::set_data(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.ConsoleOutput.data)
}
inline ::std::string* PROTOBUF_NONNULL ConsoleOutput::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:elmos.v1.ConsoleOutput.data)
  return _s;
}
inline const ::std::string& ConsoleOutput::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void ConsoleOutput::_internal_set_data(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ConsoleOutput::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ConsoleOutput::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.ConsoleOutput.data)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.data_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_.Set("", GetArena());
  }
  return released;
}
inline void ConsoleOutput::set_allocated_data(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.ConsoleOutput.data)
}

// int64 timestamp_ms = 2;
inline void ConsoleOutput::clear_timestamp_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ms_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t ConsoleOutput::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:elmos.v1.ConsoleOutput.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void ConsoleOutput::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:elmos.v1.ConsoleOutput.timestamp_ms)
}
inline ::int64_t ConsoleOutput::_internal_timestamp_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_ms_;
}
inline void ConsoleOutput::_internal_set_timestamp_ms(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ms_ = value;
}

// -------------------------------------------------------------------

// QEMUStopped

// int32 exit_code = 1;
inline void QEMUStopped::clear_exit_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exit_code_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t QEMUStopped::exit_code() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStopped.exit_code)
  return _internal_exit_code();
}
inline void QEMUStopped::set_exit_code(::int32_t value) {
  _internal_set_exit_code(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStopped.exit_code)
}
inline ::int32_t QEMUStopped::_internal_exit_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exit_code_;
}
inline void QEMUStopped::_internal_set_exit_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exit_code_ = value;
}

// int64 uptime_ms = 2;
inline void QEMUStopped::clear_uptime_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uptime_ms_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t QEMUStopped::uptime_ms() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStopped.uptime_ms)
  return _internal_uptime_ms();
}
inline void QEMUStopped::set_uptime_ms(::int64_t value) {
  _internal_set_uptime_ms(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStopped.uptime_ms)
}
inline ::int64_t QEMUStopped::_internal_uptime_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uptime_ms_;
}
inline void QEMUStopped::_internal_set_uptime_ms(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uptime_ms_ = value;
}

// -------------------------------------------------------------------

// QEMUError

// string message = 1;
inline void QEMUError::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& QEMUError::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QEMUError::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUError.message)
}
inline ::std::string* PROTOBUF_NONNULL QEMUError::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUError.message)
  return _s;
}
inline const ::std::string& QEMUError::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void QEMUError::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QEMUError::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QEMUError::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUError.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void QEMUError::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.QEMUError.message)
}

// -------------------------------------------------------------------

// QEMUStopRequest

// -------------------------------------------------------------------

// QEMUStopResponse

// bool success = 1;
inline void QEMUStopResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool QEMUStopResponse::success() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStopResponse.success)
  return _internal_success();
}
inline void QEMUStopResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStopResponse.success)
}
inline bool QEMUStopResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void QEMUStopResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string message = 2;
inline void QEMUStopResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& QEMUStopResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStopResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QEMUStopResponse::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStopResponse.message)
}
inline ::std::string* PROTOBUF_NONNULL QEMUStopResponse::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUStopResponse.message)
  return _s;
}
inline const ::std::string& QEMUStopResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void QEMUStopResponse::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QEMUStopResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QEMUStopResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUStopResponse.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void QEMUStopResponse::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.QEMUStopResponse.message)
}

// -------------------------------------------------------------------

// QEMUInputRequest

// bytes data = 1;
inline void QEMUInputRequest::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& QEMUInputRequest::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUInputRequest.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QEMUInputRequest::set_data(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUInputRequest.data)
}
inline ::std::string* PROTOBUF_NONNULL QEMUInputRequest::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUInputRequest.data)
  return _s;
}
inline const ::std::string& QEMUInputRequest::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void QEMUInputRequest::_internal_set_data(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QEMUInputRequest::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QEMUInputRequest::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUInputRequest.data)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.data_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_.Set("", GetArena());
  }
  return released;
}
inline void QEMUInputRequest::set_allocated_data(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.QEMUInputRequest.data)
}

// -------------------------------------------------------------------

// QEMUInputResponse

// bool success = 1;
inline void QEMUInputResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool QEMUInputResponse::success() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUInputResponse.success)
  return _internal_success();
}
inline void QEMUInputResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUInputResponse.success)
}
inline bool QEMUInputResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void QEMUInputResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// QEMUStatusRequest

// -------------------------------------------------------------------

// QEMUStatus

// bool running = 1;
inline void QEMUStatus::clear_running() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.running_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool QEMUStatus::running() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStatus.running)
  return _internal_running();
}
inline void QEMUStatus::set_running(bool value) {
  _internal_set_running(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStatus.running)
}
inline bool QEMUStatus::_internal_running() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.running_;
}
inline void QEMUStatus::_internal_set_running(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.running_ = value;
}

// int32 pid = 2;
inline void QEMUStatus::clear_pid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t QEMUStatus::pid() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStatus.pid)
  return _internal_pid();
}
inline void QEMUStatus::set_pid(::int32_t value) {
  _internal_set_pid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStatus.pid)
}
inline ::int32_t QEMUStatus::_internal_pid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pid_;
}
inline void QEMUStatus::_internal_set_pid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_ = value;
}

// int64 uptime_ms = 3;
inline void QEMUStatus::clear_uptime_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uptime_ms_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int64_t QEMUStatus::uptime_ms() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStatus.uptime_ms)
  return _internal_uptime_ms();
}
inline void QEMUStatus::set_uptime_ms(::int64_t value) {
  _internal_set_uptime_ms(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStatus.uptime_ms)
}
inline ::int64_t QEMUStatus::_internal_uptime_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uptime_ms_;
}
inline void QEMUStatus::_internal_set_uptime_ms(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uptime_ms_ = value;
}

// string arch = 4;
inline void QEMUStatus::clear_arch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arch_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& QEMUStatus::arch() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStatus.arch)
  return _internal_arch();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void QEMUStatus::set_arch(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.arch_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStatus.arch)
}
inline ::std::string* PROTOBUF_NONNULL QEMUStatus::mutable_arch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_arch();
  // @@protoc_insertion_point(field_mutable:elmos.v1.QEMUStatus.arch)
  return _s;
}
inline const ::std::string& QEMUStatus::_internal_arch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arch_.Get();
}
inline void QEMUStatus::_internal_set_arch(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arch_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL QEMUStatus::_internal_mutable_arch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.arch_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE QEMUStatus::release_arch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:elmos.v1.QEMUStatus.arch)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.arch_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.arch_.Set("", GetArena());
  }
  return released;
}
inline void QEMUStatus::set_allocated_arch(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.arch_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.arch_.IsDefault()) {
    _impl_.arch_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:elmos.v1.QEMUStatus.arch)
}

// int32 memory_mb = 5;
inline void QEMUStatus::clear_memory_mb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_mb_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t QEMUStatus::memory_mb() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStatus.memory_mb)
  return _internal_memory_mb();
}
inline void QEMUStatus::set_memory_mb(::int32_t value) {
  _internal_set_memory_mb(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStatus.memory_mb)
}
inline ::int32_t QEMUStatus::_internal_memory_mb() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memory_mb_;
}
inline void QEMUStatus::_internal_set_memory_mb(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_mb_ = value;
}

// int32 cpus = 6;
inline void QEMUStatus::clear_cpus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpus_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t QEMUStatus::cpus() const {
  // @@protoc_insertion_point(field_get:elmos.v1.QEMUStatus.cpus)
  return _internal_cpus();
}
inline void QEMUStatus::set_cpus(::int32_t value) {
  _internal_set_cpus(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:elmos.v1.QEMUStatus.cpus)
}
inline ::int32_t QEMUStatus::_internal_cpus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpus_;
}
inline void QEMUStatus::_internal_set_cpus(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpus_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace elmos


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // api_2fproto_2fqemu_2eproto_2epb_2eh
