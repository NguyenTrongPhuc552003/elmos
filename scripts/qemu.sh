#!/bin/bash
# scripts/qemu.sh
# Handles QEMU execution for a disk-based Linux kernel (ext4 rootfs on disk.img).
# Requires: KERNEL_DIR, TARGET_ARCH, DISK_IMAGE (from common.env)

# ─────────────────────────────────────────────────────────────
# Configurable constants
# ─────────────────────────────────────────────────────────────
QEMU_GDB_PORT=1234 # Port for GDB stub

# ─────────────────────────────────────────────────────────────
# 1. Architecture-specific QEMU configuration
# ─────────────────────────────────────────────────────────────
_configure_qemu_for_arch() {
	# Default settings
	QEMU_MEMORY="2G"
	QEMU_SMP="$(sysctl -n hw.logicalcpu)"

	case "$TARGET_ARCH" in
	riscv)
		QEMU_BIN="qemu-system-riscv64"
		QEMU_MACHINE="virt"
		QEMU_CPU="rv64"
		QEMU_CONSOLE="ttyS0"
		QEMU_BIOS="-bios default" # Uses built-in OpenSBI
		;;

	arm64)
		QEMU_BIN="qemu-system-aarch64"
		QEMU_MACHINE="virt"
		QEMU_CPU="cortex-a72" # Reliable and widely supported
		QEMU_CONSOLE="ttyAMA0"
		QEMU_BIOS="" # EFI not needed for direct kernel boot on virt
		;;

	arm)
		QEMU_BIN="qemu-system-arm"
		QEMU_MACHINE="virt"
		QEMU_CPU="cortex-a15" # Reliable and widely supported
		QEMU_CONSOLE="ttyAMA0"
		QEMU_BIOS="" # EFI not needed for direct kernel boot on virt
		;;

	*)
		echo -e "  [${RED}ERROR${NC}] Unsupported TARGET_ARCH for QEMU: ${TARGET_ARCH}" >&2
		exit 1
		;;

	esac
}

# ─────────────────────────────────────────────────────────────
# 2. Generate Guest Orchestrator
# ─────────────────────────────────────────────────────────────
_prepare_guest_modules() {
	local sync_file="${MODULES_DIR}/guesync.sh"

	# Load the state from module.cfg (generated by module.sh)
	local MOD_CONFIG="${MODULES_DIR}/module.cfg"
	if [ ! -f "$MOD_CONFIG" ]; then
		echo "#!/bin/sh" >"$sync_file"
		return
	fi

	# Create the guesync.sh script
	source "$MOD_CONFIG"
	{
		echo "#!/bin/sh"
		echo "# Auto-generated by macOS qemu.sh"
		echo "echo '  [GUEST] Processing module queues...'"

		# Handle REMOVALS first
		for mod in "${MODULE_REM[@]}"; do
			if [ "$mod" = "*" ]; then
				echo "lsmod | awk '{print \$1}' | xargs rmmod 2>/dev/null"
			else
				echo "rmmod $mod 2>/dev/null"
			fi
		done

		# Handle INSERTIONS
		for mod in "${MODULE_INS[@]}"; do
			if [ "$mod" = "*" ]; then
				# Find all .ko files in subdirectories
				echo "find /mnt/modules -name '*.ko' -exec insmod {} \;"
			else
				# Find specific module .ko
				echo "insmod /mnt/modules/$mod/$mod.ko 2>/dev/null"
			fi
		done
	} >"$sync_file"
	chmod +x "$sync_file"
}

# ─────────────────────────────────────────────────────────────
# 3. Core execution logic
# ─────────────────────────────────────────────────────────────
_execute_qemu() {
	local GDB_FLAGS="$1"    # e.g., "-s -S" for gdb
	local VERBOSE_MODE="$2" # if "verbose", skip -nographic

	# Architecture-specific setup
	_configure_qemu_for_arch

	# Prepare guest module orchestrator
	_prepare_guest_modules

	local KERNEL_IMAGE="${KERNEL_DIR}/arch/${TARGET_ARCH}/boot/Image"
	local VMLINUX="${KERNEL_DIR}/vmlinux"

	# Minimum components validation
	if ! command -v "$QEMU_BIN" >/dev/null 2>&1; then
		echo -e "  [${RED}ERROR${NC}] $QEMU_BIN not found. Install QEMU via Homebrew: brew install qemu" >&2
		exit 1
	fi

	if [ ! -f "$KERNEL_IMAGE" ]; then
		echo -e "  [${RED}ERROR${NC}] Kernel Image not found: $KERNEL_IMAGE"
		echo "  Run './run.sh build' first."
		exit 1
	fi

	if [ ! -f "$DISK_IMAGE" ]; then
		echo -e "  [${RED}ERROR${NC}] Disk image not found: $DISK_IMAGE"
		echo "  Run './run.sh rootfs' first to create the root filesystem."
		exit 1
	fi

	echo -e "  [${YELLOW}QEMU${NC}] Starting ${GREEN}${TARGET_ARCH}${NC} emulation with disk-based rootfs..."
	[ -n "$GDB_FLAGS" ] && echo -e "  [${YELLOW}DEBUG${NC}] GDB stub enabled. Connect using port ${QEMU_GDB_PORT}"

	# Base command
	local QEMU_CMD=(
		"$QEMU_BIN"
		-m "$QEMU_MEMORY"
		-smp "$QEMU_SMP"
		-kernel "$KERNEL_IMAGE"
		$QEMU_BIOS
		-machine "$QEMU_MACHINE"
		${QEMU_CPU:+-cpu "$QEMU_CPU"}

		# Disk: virtio-blk with our ext4 image
		-drive file="${DISK_IMAGE}",format=raw,if=virtio

		# Basic GPU (virtio-gpu-pci)
		-device virtio-gpu-pci

		# Networking: user-mode + SSH forwarding (host:2222 -> guest:22)
		-device virtio-net-device,netdev=net0
		-netdev user,id=net0,hostfwd=tcp::2222-:22

		# Serial console
		-serial mon:stdio

		# Sharing Setup for Kernel Modules
		-fsdev "local,id=moddev,path=${MODULES_DIR},security_model=none"
		-device "virtio-9p-pci,fsdev=moddev,mount_tag=modules_mount"
	)

	# Graphics mode
	if [ "$VERBOSE_MODE" != "verbose" ]; then
		QEMU_CMD+=(-nographic)
	fi

	# GDB support
	[ -n "$GDB_FLAGS" ] && QEMU_CMD+=($GDB_FLAGS)

	# Kernel command line: critical for disk boot
	local KERNEL_CMDLINE="console=${QEMU_CONSOLE} root=/dev/vda rw init=/init earlycon"
	QEMU_CMD+=(-append "$KERNEL_CMDLINE")

	# Show and execute
	echo -e "  [${YELLOW}CMD${NC}] ${QEMU_CMD[*]}"
	"${QEMU_CMD[@]}"
}

# ─────────────────────────────────────────────────────────────
# 4. Check if debug info is enabled in kernel config
# ─────────────────────────────────────────────────────────────
_check_debug_info_enabled() {
	local config_file="${KERNEL_DIR}/.config" # Use actual .config instead of defconfig

	if [ ! -f "$config_file" ]; then
		echo -e "  [${RED}ERROR${NC}] Kernel config not found: $config_file"
		echo "  Run './run.sh config defconfig' or similar first."
		return 1
	fi

	# Check if either:
	# - CONFIG_DEBUG_KERNEL=y (parent: enables the whole Kernel debugging section)
	# - OR CONFIG_DEBUG_INFO_DWARF5=y (the actual DWARF setting)
	if grep -q "^CONFIG_DEBUG_KERNEL=y" "$config_file" ||
		grep -q "^CONFIG_DEBUG_INFO_DWARF5=y" "$config_file"; then
		return 0
	fi

	echo -e "  [${RED}ERROR${NC}] Kernel debugging symbols not properly enabled!"
	echo "  Required: Kernel hacking → Kernel debugging must be enabled"
	echo "            AND Debug information → Generate DWARF debug info"
	echo
	echo "  Enable via:"
	echo "    ./run.sh config menuconfig"
	echo "    → Kernel hacking"
	echo "        → [*] Kernel debugging"
	echo "        → Compile-time checks and compiler options"
	echo "            → Debug information"
	echo "                → [*] Generate DWARF Version 5 debug info (or toolchain default)"
	echo
	echo "  Alternatively, ensure at least one of these is set in .config:"
	echo "    CONFIG_DEBUG_KERNEL=y"
	echo "    CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y"
	return 1
}

# ─────────────────────────────────────────────────────────────
# Unified QEMU runner – handles debug and verbose modes
# ─────────────────────────────────────────────────────────────
run_qemu() {
	local debug_mode=""
	local verbose_mode=""

	while [ $# -gt 0 ]; do
		case "$1" in
		-d | --debug)
			debug_mode="yes"
			shift
			# Check if next arg is 0 or 1 (optional toggle)
			if [[ "$1" =~ ^[01]$ ]]; then
				debug_submode="$1"
				shift
			else
				debug_submode="0" # default
			fi
			;;
		-v | --verbose)
			verbose_mode="yes"
			shift
			;;
		-h | --help)
			cat <<EOF
Usage: ./run.sh qemu [options]

Options:
  -d    Start QEMU as a server and wait for GDB connection (Port ${QEMU_GDB_PORT})
  -d 1  Launch cross-arch GDB and auto-connect to the server
  -v    Enable graphical output (window mode)
EOF
			return 0
			;;
		*)
			echo -e "  [${RED}ERROR${NC}] Unknown argument: $1"
			echo "  Use './run.sh qemu -h' for help."
			return 1
			;;
		esac
	done

	# NORMAL BOOT
	if [ -z "$debug_mode" ]; then
		_execute_qemu "" "$verbose_mode"
		return 0
	fi

	# DEBUG SERVER (Submode 0)
	if [ "$debug_submode" = "0" ]; then
		_check_debug_info_enabled || return 1
		_execute_qemu "-s -S" "$verbose_mode"
		return 0
	fi

	# GDB CLIENT (Submode 1)
	if [ "$debug_submode" = "1" ]; then
		local gdb_bin

		# Determine cross-GDB binary based on TARGET_ARCH
		case "$TARGET_ARCH" in
		riscv) gdb_bin="riscv64-elf-gdb" ;;
		arm64) gdb_bin="aarch64-elf-gdb" ;;
		arm) gdb_bin="arm-none-eabi-gdb" ;;
		*)
			echo -e "  [${RED}ERROR${NC}] Unsupported TARGET_ARCH for GDB: ${TARGET_ARCH}" >&2
			return 1
			;;
		esac

		if ! command -v "$gdb_bin" >/dev/null 2>&1; then
			echo -e "  [${RED}ERROR${NC}] Cross-GDB not found: $gdb_bin"
			return 1
		fi

		local vmlinux="${KERNEL_DIR}/vmlinux"
		[ ! -f "$vmlinux" ] && {
			echo "  [ERROR] vmlinux missing."
			return 1
		}

		echo -e "  [${GREEN}GDB${NC}] Connecting to localhost:${QEMU_GDB_PORT}..."

		# Launch GDB with auto-attach commands
		exec "$gdb_bin" "$vmlinux" \
			-ex "target remote localhost:${QEMU_GDB_PORT}" \
			-ex "layout src" \
			-ex "break start_kernel"
	fi
}
