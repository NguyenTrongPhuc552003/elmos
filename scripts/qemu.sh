#!/bin/bash
# scripts/qemu.sh
# Handles QEMU execution for a disk-based Linux kernel (ext4 rootfs on disk.img).
# Requires: KERNEL_DIR, TARGET_ARCH, DISK_IMAGE (from common.env)

# ─────────────────────────────────────────────────────────────
# Configurable constants
# ─────────────────────────────────────────────────────────────
QEMU_GDB_PORT=1234 # Port for GDB stub

# ─────────────────────────────────────────────────────────────
# 1. Architecture-specific QEMU configuration
# ─────────────────────────────────────────────────────────────
_configure_qemu_for_arch() {
	# Default settings
	QEMU_MEMORY="2G"
	QEMU_SMP="$(sysctl -n hw.logicalcpu)"

	case "$TARGET_ARCH" in
	riscv)
		QEMU_BIN="qemu-system-riscv64"
		QEMU_MACHINE="virt"
		QEMU_CPU="rv64"
		QEMU_CONSOLE="ttyS0"
		QEMU_BIOS="-bios default" # Uses built-in OpenSBI
		;;

	arm64)
		QEMU_BIN="qemu-system-aarch64"
		QEMU_MACHINE="virt"
		QEMU_CPU="cortex-a72" # Reliable and widely supported
		QEMU_CONSOLE="ttyAMA0"
		QEMU_BIOS="" # EFI not needed for direct kernel boot on virt
		;;

	arm)
		QEMU_BIN="qemu-system-arm"
		QEMU_MACHINE="virt"
		QEMU_CPU="cortex-a15" # Reliable and widely supported
		QEMU_CONSOLE="ttyAMA0"
		QEMU_BIOS="" # EFI not needed for direct kernel boot on virt
		;;

	*)
		echo -e "  [${RED}ERROR${NC}] Unsupported TARGET_ARCH for QEMU: ${TARGET_ARCH}" >&2
		exit 1
		;;

	esac
}

# ─────────────────────────────────────────────────────────────
# 2. Generate Guest Orchestrator
# ─────────────────────────────────────────────────────────────
_prepare_guest_modules() {
	local sync_file="${MODULES_DIR}/guesync.sh"

	# Load the state from module.cfg (generated by module.sh)
	local MOD_CONFIG="${MODULES_DIR}/module.cfg"
	if [ ! -f "$MOD_CONFIG" ]; then
		echo "#!/bin/sh" >"$sync_file"
		return
	fi

	# Create the guesync.sh script
	source "$MOD_CONFIG"
	{
		echo "#!/bin/sh"
		echo "# Auto-generated by macOS qemu.sh"
		echo "echo '  [GUEST] Processing module queues...'"

		# Handle REMOVALS first
		for mod in "${MODULE_REM[@]}"; do
			if [ "$mod" = "*" ]; then
				echo "lsmod | awk '{print \$1}' | xargs rmmod 2>/dev/null"
			else
				echo "rmmod $mod 2>/dev/null"
			fi
		done

		# Handle INSERTIONS
		for mod in "${MODULE_INS[@]}"; do
			if [ "$mod" = "*" ]; then
				# Find all .ko files in subdirectories
				echo "find /mnt/modules -name '*.ko' -exec insmod {} \;"
			else
				# Find specific module .ko
				echo "insmod /mnt/modules/$mod/$mod.ko 2>/dev/null"
			fi
		done
	} >"$sync_file"
	chmod +x "$sync_file"
}

# ─────────────────────────────────────────────────────────────
# 3. Core execution logic
# ─────────────────────────────────────────────────────────────
_execute_qemu() {
	local GDB_FLAGS="$1"    # e.g., "-s -S"
	local VERBOSE_MODE="$2" # "yes" → graphical mode

	# Architecture-specific setup
	_configure_qemu_for_arch

	# Prepare guest module orchestrator
	_prepare_guest_modules

	local kernel="${KERNEL_DIR}/arch/${TARGET_ARCH}/boot/Image"
	local vmlinux="${KERNEL_DIR}/vmlinux"

	# Basic validation
	command -v "$QEMU_BIN" >/dev/null || {
		echo -e "  [${RED}ERROR${NC}] $QEMU_BIN not found (brew install qemu)"
		exit 1
	}
	[[ -f "$kernel" ]] || {
		echo -e "  [${RED}ERROR${NC}] Kernel not found: $kernel (run './run.sh build')"
		exit 1
	}
	[[ -f "$DISK_IMAGE" ]] || {
		echo -e "  [${RED}ERROR${NC}] Disk image missing: $DISK_IMAGE (run './run.sh rootfs')"
		exit 1
	}

	echo -e "  [${YELLOW}QEMU${NC}] Starting ${GREEN}${TARGET_ARCH}${NC} emulation..."
	[[ -n "$GDB_FLAGS" ]] && echo -e "  [${YELLOW}DEBUG${NC}] GDB stub active on port ${QEMU_GDB_PORT}"

	# Base QEMU command
	local cmd=(
		"$QEMU_BIN"
		-m "$QEMU_MEMORY"
		-smp "$QEMU_SMP"
		-kernel "$kernel"
		$QEMU_BIOS
		-machine "$QEMU_MACHINE"
		${QEMU_CPU:+-cpu "$QEMU_CPU"}

		# Disk: virtio-blk with our ext4 image
		-drive file="${DISK_IMAGE}",format=raw,if=virtio

		# Networking: user-mode + SSH forwarding (host:2222 -> guest:22)
		-device virtio-net-device,netdev=net0
		-netdev user,id=net0,hostfwd=tcp::2222-:22

		# Sharing Setup for Kernel Modules
		-fsdev local,id=moddev,path="${MODULES_DIR}",security_model=none
		-device virtio-9p-pci,fsdev=moddev,mount_tag=modules_mount
	)

	# Console & display mode
	local append="root=/dev/vda rw init=/init earlycon"
	if [ "$VERBOSE_MODE" = "yes" ]; then
		cmd+=(
			-display cocoa
			-device virtio-gpu-pci
			-device virtio-keyboard-pci
			-device virtio-mouse-pci
		)
		# Graphical behavior: send output to new window (tty0)
		append+=" console=tty0"
	else
		cmd+=(
			-nographic
			-serial mon:stdio
		)
		# Default behavior: send output only to serial
		append+=" console=${QEMU_CONSOLE}"
	fi

	cmd+=(-append "$append")
	[[ -n "$GDB_FLAGS" ]] && cmd+=($GDB_FLAGS) # Add GDB flags if any

	# Execute
	echo -e "  [${YELLOW}CMD${NC}] ${cmd[*]}"
	"${cmd[@]}"
}

# ─────────────────────────────────────────────────────────────
# 4. Check if debug info is enabled in kernel config
# ─────────────────────────────────────────────────────────────
_check_debug_info_enabled() {
	local config_file="${KERNEL_DIR}/.config" # Use actual .config instead of defconfig

	if [ ! -f "$config_file" ]; then
		echo -e "  [${RED}ERROR${NC}] Kernel config not found: $config_file"
		echo "  Run './run.sh config defconfig' or similar first."
		return 1
	fi

	# Check if either:
	# - CONFIG_DEBUG_KERNEL=y (parent: enables the whole Kernel debugging section)
	# - OR CONFIG_DEBUG_INFO_DWARF5=y (the actual DWARF setting)
	if grep -q "^CONFIG_DEBUG_KERNEL=y" "$config_file" ||
		grep -q "^CONFIG_DEBUG_INFO_DWARF5=y" "$config_file"; then
		return 0
	fi

	echo -e "  [${RED}ERROR${NC}] Kernel debugging symbols not properly enabled!"
	echo "  Required: Kernel hacking → Kernel debugging must be enabled"
	echo "            AND Debug information → Generate DWARF debug info"
	echo
	echo "  Enable via:"
	echo "    ./run.sh config menuconfig"
	echo "    → Kernel hacking"
	echo "        → [*] Kernel debugging"
	echo "        → Compile-time checks and compiler options"
	echo "            → Debug information"
	echo "                → [*] Generate DWARF Version 5 debug info (or toolchain default)"
	echo
	echo "  Alternatively, ensure at least one of these is set in .config:"
	echo "    CONFIG_DEBUG_KERNEL=y"
	echo "    CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y"
	return 1
}

# ─────────────────────────────────────────────────────────────
# 5. Verify GPU and Virtual Terminal kernel configs
# ─────────────────────────────────────────────────────────────
_check_gpu_vt_enabled() {
	local config_file="${KERNEL_DIR}/.config"
	local missing_configs=()

	# Basic check if .config exists
	if [ ! -f "$config_file" ]; then
		echo -e "  [${RED}ERROR${NC}] Kernel configuration (.config) not found."
		echo "  Please run './run.sh config' first."
		exit 1
	fi

	# List of required configurations for graphical console
	local required=(
		"CONFIG_DRM=y"
		"CONFIG_DRM_VIRTIO_GPU=y"
		"CONFIG_FB=y"
		"CONFIG_FRAMEBUFFER_CONSOLE=y"
	)

	for cfg in "${required[@]}"; do
		if ! grep -q "^${cfg}$" "$config_file"; then
			missing_configs+=("$cfg")
		fi
	done

	# If any configs are missing, block execution and advise the user
	if [ ${#missing_configs[@]} -ne 0 ]; then
		echo -e "  [${RED}ERROR${NC}] Missing kernel GPU/VT support for graphical mode:"
		for missing in "${missing_configs[@]}"; do
			echo "    - $missing"
		done
		echo
		echo -e "  ${YELLOW}Action Required:${NC}"
		echo "  Please run the following command to enable desktop support:"
		echo -e "  ${GREEN}./run.sh config kvm_guest.config${NC}"
		echo
		exit 1
	fi
}

# ─────────────────────────────────────────────────────────────
# Unified QEMU runner – handles debug and verbose modes
# ─────────────────────────────────────────────────────────────
run_qemu() {
	local debug_mode=""
	local verbose_mode=""

	while [ $# -gt 0 ]; do
		case "$1" in
		-d | --debug)
			debug_mode="yes"
			shift
			# Check if next arg is 0 or 1 (optional toggle)
			if [[ "$1" =~ ^[01]$ ]]; then
				debug_submode="$1"
				shift
			else
				debug_submode="0" # default
			fi
			;;
		-v | --verbose)
			verbose_mode="yes"
			shift
			;;
		-h | --help)
			cat <<EOF
Usage: ./run.sh qemu [options]

Options:
  -d    Start QEMU as a server and wait for GDB connection (Port ${QEMU_GDB_PORT})
  -d 1  Launch cross-arch GDB and auto-connect to the server
  -v    Enable graphical output (window mode)
EOF
			return 0
			;;
		*)
			echo -e "  [${RED}ERROR${NC}] Unknown argument: $1"
			echo "  Use './run.sh qemu -h' for help."
			return 1
			;;
		esac
	done

	# Perform GPU check if verbose mode is requested
	if [ "$verbose_mode" = "yes" ]; then
		_check_gpu_vt_enabled
	fi

	# NORMAL BOOT
	if [ -z "$debug_mode" ]; then
		_execute_qemu "" "$verbose_mode"
		return 0
	fi

	# DEBUG SERVER (Submode 0)
	if [ "$debug_submode" = "0" ]; then
		_check_debug_info_enabled || return 1
		_execute_qemu "-s -S" "$verbose_mode"
		return 0
	fi

	# GDB CLIENT (Submode 1)
	if [ "$debug_submode" = "1" ]; then
		local gdb_bin

		# Determine cross-GDB binary based on TARGET_ARCH
		case "$TARGET_ARCH" in
		riscv) gdb_bin="riscv64-elf-gdb" ;;
		arm64) gdb_bin="aarch64-elf-gdb" ;;
		arm) gdb_bin="arm-none-eabi-gdb" ;;
		*)
			echo -e "  [${RED}ERROR${NC}] Unsupported TARGET_ARCH for GDB: ${TARGET_ARCH}" >&2
			return 1
			;;
		esac

		if ! command -v "$gdb_bin" >/dev/null 2>&1; then
			echo -e "  [${RED}ERROR${NC}] Cross-GDB not found: $gdb_bin"
			return 1
		fi

		local vmlinux="${KERNEL_DIR}/vmlinux"
		[ ! -f "$vmlinux" ] && {
			echo "  [ERROR] vmlinux missing."
			return 1
		}

		echo -e "  [${GREEN}GDB${NC}] Connecting to localhost:${QEMU_GDB_PORT}..."

		# Launch GDB with auto-attach commands
		exec "$gdb_bin" "$vmlinux" \
			-ex "target remote localhost:${QEMU_GDB_PORT}" \
			-ex "layout src" \
			-ex "break start_kernel"
	fi
}
